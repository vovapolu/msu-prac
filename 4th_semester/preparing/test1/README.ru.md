## Подготовка к первой контрольной:

*Read this in other languages: [English](README.md), [Русский](README.ru.md).*

<b> [v1_1](./v1_1.cpp): </b><br>
```cpp
Опишите функцию set_min, которая принимает два параметра - переменные типа int, определяет,
в какой из двух переменных значение меньше, и заносит это значение в обе переменные.
Вызов функции будет выполняться с указанием в качестве параметров имён переменных без каких-либо
дополнительных операций (взятия адреса и т.п.)
```

<br> <b> [v1_2](./v1_2.cpp): </b><br>
```cpp
Опишите класс Flag, объект которого может находиться в одном из двух состояний - 
«взведён» (оп) и «сброшен» (off). Предусмотрите методы SetOn и SetOff, устанавливающие флаг
в соответствующее положение, а также метод IsOn, возвращающий логическое значение (истина, если объект
находится в состоянии «взведён», ложь в противном случае), который должен
допускать работу для константных объектов.
```

<br> <b> [v1_3](./v1_3.cpp): </b><br>
```cpp   
Модифицируйте класс Flag из предыдущей задачи так, чтобы его объекты (без явного применения к ним каких-либо
дополнительных операций) можно было использовать в качестве логического значения (условного
выражения), например, в операторах if, while и т.п. Это должно работать в том числе и для константных объектов. 
```

<br> <b> [v1_4](./v1_4.cpp): </b><br>
```cpp
Опишите класс Watched, допускающий создание объекта без указания параметров. Реализуйте в этом классе
метод Amount так, чтобы вызвать его можно было без объекта, указав имя класса. Метод Amount должен возвращать
целое число, соответствующее количеству существующих в настояший момент объектов класса Counted. 
Не забудьте про случай создания объекта как копии другого объекта!
```

<br> <b> [v1_5](./v1_5.cpp): </b><br>
```cpp
Опишите классы A и В так, чтобы (при условии, что a и b - объекты соответственно А и класса В):
• Выражения вида a[b] и b[a] были равны числу 75 (здесь и далее подразумеваются числа типа int);
• Выражение а() было равно числу 50, выражение a(b) было равно числу 100, выражение a(b, b)
было равно числу 150, выражение b(a) было равно числу 200;
• Выражение а(а,а,а) успешно проходило компиляцию в качестве целочисленного, во при попытке
его вычислить выбрасывало исключение типа А;
• Выражение --а было равно числу 500, выражение а-- - числу 501.
```

<br> <b> [v1_6](./v1_6.cpp): </b><br>
```cpp 
Опишите класс D и (при необходимости) дополнительные классы или структуры так, чтобы (при условии,
что d есть объект класса D) выражение d->1 представляло собой целочисленную переменную, которой можно
присваивать значения, которая сохраняет присвоенное значение и из которой это значение можно извлечь как
из обычной переменной; в случае, если в программе описано больше одного объекта класса D,
каждому такому объекту должна соответствовать своя собственная целочисленная переменная, доступная через
операцию ->f. то есть такие переменные не должны конфликтовать. Объект класса D должен допускать
создание без указания параметров. Любая динамическая память должна корректно освобождаться.
```

<br> <b> [v1_7](./v1_7.cpp): </b><br>
```cpp   
Опишите класс IntQueue, представляющий понятие «очереди целых чисел", реализованный через односвязный
список с указателями на начало и конец (возможности стандартной библиотеки С++ не использовать!).
Предусмотрите операции <<= (левый операнд - объект вашего класса, правый - целочисленное выражение,
операция добавляет элемент в конец очереди) и >>= (правый операнд - переменная типа int, 
операция извлекает элемент из начала очереди; если нечего извлекать, бросьте исключение
класса QueueEmpty, который опишите сами). Предусмотрите метод Amount, возвращающий текущее количество 
элементов в очереди. 
Вся выделенная динамическая память должна быть корректно освобождена - память от извлекаемых элементов
освобождается при их извлечении, память от всего остального освобождается при уничтожении объекта очереди.
```

<br> <b> [v1_8](./v1_8.cpp): </b><br>
```cpp
Модифицируйте класс IntQueue из предыдущей задачи, снабдив его виртуальной функцией Check, принимающей параметр
типа int и возвращающей логическое значение; функция должна допускать работу для константных объектов. В классе
IntQueue функция Check должна всегда возвращать «истину», но предполагается, что классы-наследники могут
заменить эту функцию своей версией таковой. При добавлении нового числа в очередь это число должно проверяться
вызовом функции Check, и если функция вернула истину, число должно помещаться в очередь, в противном случае - 
игнорироваться. Унаследуйте от класса IntQueue класс EvenFilter, принимающий для помещения в очередь только
чётные числа. Этот класс должен отличаться от базового только функцией Check. Учтите, что в ходе тестирования
от класса будут наследоваться также другие потомки.
```

<br> <b> [v2_1](./v2_1.cpp): </b><br>
```cpp   
Опишите класс А, а в нём открытую функцию f с пустым списком параметров, возвращающую целое число и допускающую
вызов без объекта, те с указанием имени класса. Функция при первом её вызове должна возвращать ноль, а при каждом
следующем - число на единицу большее предыдущего.
```

<br> <b> [v2_2](./v2_2.cpp): </b><br>
```cpp
Опишите класс Functor таким образом, чтобы (при условии, что f - объект этого класса) выражение f(x,y)
было равно сумме чисел x и y. Выражение должно работать в том числе и для константных объектов.
```

<br> <b> [v2_3](./v2_3.cpp): </b><br>
```cpp
Опишите класс PseudoArray, представляющий собой "псевдомассив" целых чисел. К объектам класса должна быть применима
операция индексирования, аргумент которой, имеющий тип int, должен игнорироваться, то есть должно создаваться
впечатление, что в массиве столько элементов, сколько существует различных значений int, причём все элементы
равны одному и тому же числу. Начальное значение всех «элементов» - ноль. Изменение значения производится присваиванием,
как для обычных массивов. Извлечение значения элементов должно работать в том числе для константных объектов.
```

<br> <b> [v2_4](./v2_4.cpp): </b><br>
```cpp
Опишите класс Smart и, при необходимости, дополнительные классы таким образом, чтобы (если s - объект класса Smart, 
возможно константного типа, выражение t = s[х], где t - целочисленная переменая, а x - целочисленное выражение, заносило
в t значение, превосходящее х на единицу, а выражение вида t = s[x][y] заносило в произведение чисел х и у.
```

<br> <b> [v3_1](./v3_1.cpp): </b><br>
```cpp
Создайте класс Assign (и, при необходимости, дополнительные классы) так, чтобы выражение вида а->f(x,у)
(где а - объект класса присваивало целочисленной переменной х значение у, при этом присвоенное значение запоминалось
в объекте и могло быть получено методом Get().
```

<br> <b> [v3_2](./v3_2.cpp): </b><br>
```cpp 
Модифицируйте класс Assign из предыдущей задачи так, чтобы присвоить таким способом новое значение можно было
переменной любого типа, если только для неё в принципе существует операция присваивания (в том числе для переменных,
тип которых запрещает копирование, но позволяет присваивание). В этой версии не нужно реализовывать
запоминание значения и метод Get().
```

<br> <b> [v3_3](./v3_3.cpp): </b><br>
```cpp
Опишите класс М и (при необходимости) дополнительные классы или структуры так, чтобы (при условии, что m есть объект класса M)
выражение m(m) представляло собой целочисленную переменную, которой можно присваивать значения, которая сохраняет
присвоенное значение и из которой значение можно извлечь как из обычной переменной; в случае, если в программе описано
больше одного объекта класса М, каждому такому объекту должна соответствовать своя собственная целочисленная переменная,
доступная через операцию вида x(x). При этом выражение вида m(x), где x - объект того же класса, отличный от m, должно
всегда возвращать ноль, а присваивание любого целочисленного значения такому выражению не должно ничего менять. Объект класса
должен допускать создание без указания параметров. Помните, что компиляция с флагом -Wall не должна вызывать предупреждений!
```

<br> <b> [v3_4](./v3_4.cpp): </b><br>
```cpp  
Опишите класс SumHold для хранения суммы целых чисел. Добавление числа к сумме должно производиться операцией <<, причём эта
операция должна быть описана так, чтобы можно было записывать «цепочки» вроде sh << 20 << 30 << 40 << 50, где sh - объект
класса SumHold; такая «цепочка» должна последовательно добавлять к сумме числа слева направо. Предусмотрите метод Get(),
возвращающий текущее значение суммы для данного объекта. Можете считать, что разрядности типа int будет достаточно.
```

<br> <b> [v3_5](./v3_5.cpp): </b><br>
```cpp
Добавьте в класс SumHold из предыдущей задачи метод GetAll(), возвращающий сумму всех чисел, добавленных с момента старта
программы во все объекты класса SumHold. При необходимости введите дополнительные поля и/или методы.
```
