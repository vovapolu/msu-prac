## Контрольная работа №1

*Read this in other languages: [English](README.md), [Русский](README.ru.md).*

<b> [v1_1](./v1_1.cpp): </b><br>

Опишите абстрактный класс `IntSeq`, хранящий некоторую последовательность целых чисел, в котором описаны чистая виртуальная функция и конструктор:

```cpp
virtual int Distance() const;   // для вычисления некоторого расстояния
IntSeq(int *pSeq, int n);       // где pSeq – адрес начала последовательности, а n – ее длина
```

Конструктор должен сохранять копию заданной последовательности в динамической памяти. Нужно предусмотреть автоматическую очистку памяти при прекращении существования объекта. <br><br>

Унаследуйте от `IntSeq` класс `OrderedSeq`, хранящей строго упорядоченную по возрастанию последовательность целых чисел (для хранения этой последовательности используется базовый класс, своих полей-данных класс `OrderedSeq` иметь не должен). При попытке задать неупорядоченную последовательность выбрасывайте исключение типа BadSeq (класс можно оставить пустым). Функцию `Distance()` определите как максимальный модуль разности между соседними элементами последовательности. <br><br>

Введите в классе операцию сложения, которая из двух упорядоченных последовательностей, строит новую последовательность посредством конкатенации, то есть к первой последовательности присоединяет вторую. Если так построенная последовательность не будет упорядоченной, то выбрасывайте исключение класса `BadConcat`, в объекте которого должны содержаться левая и правая границы обеих последовательностей, которые не удалось конкатенировать. <br><br>

В результате следующая функция `main()`:

```cpp
int main() {
    try {
        int a[] = {1, 2, 3};
        int b[] = {7, 9, 10, 13};
        int c[] = {5, 6};
        OrderedSeq sa(a, 3), sb(b, 4), sc(c, 2); 
        cout << (sa + sb).Distance() << ", " << (sc + sb).Distance() << ", " << (sa + sc + sb).Distance() << endl; 
        cout << (sb + sc) .Distance() << endl; 
    }
    catch (const BadConcat& bad) {
        cout << "Bad concatenation " << bad.GetLeft1() << ", " << bad.GetRight1() << " + " << bad.GetLeft2() << ", " << bad.GetRight2() << endl; 
    }
    catch (BadSeq) { 
        cout << "Bad sequence\n"; 
    }       
    return 0; 
}
```
должна откомпилироваться без ошибок и предупреждений, отработать и выдать:
```cpp
4, 3, 3
Bad concatenation 7, 13 + 5, 6
```
Все поля должны быть в закрытой (private) части базового класса, открытыми и защищёнными могут быть только функции-члены. Использование директивы friend запрещено. <br>
Для инициализации объектов используются конструкторы. Никакие методы не должны изменять внутренние поля объектов, допускаются только функции, возвращающие значения полей (но не меняющие ничего). Вся занятая память должна быть освобождена.

<br> <b> [v1_2](./v1_2.cpp): </b><br>

Опишите класс `Cls` (и, при необходимости другие классы) так, чтобы вычисление выражения вида `x = c[N]` (где `c` – объект класса `Cls`, `x` – переменная типа int, `N` - выражение, приводимое к int) заносило в переменную   `х`  значение `N + 1`,  а вычисление выражения вида `с[N] >>= x`   заносило в переменную `х` значение `N * 2`. <br><br>

<b>Пример:</b>

```cpp
int main() {
    Cls c;
    int x, N = 5;
    x = c[N];
    cout << x << "\n"; // print 6
    c[N] >>= x;
    cout << x << '\n'; // print 10
    return 0;
}
```

<br> <b> [v2_1](./v2_1.cpp): </b><br>

Опишите абстрактный класс `IntPair`, представляющий пару чисел типа int, котором описаны чистая виртуальная функция и конструктор:

```cpp
virtual  int  Measure() const;  // для вычисления некоторой меры
IntPair(int x, int y);
```

Унаследуйте от `IntPair` класс `IntRectangle`, задающий понятие прямоугольника с целочисленными сторонами, хранящимися в базовом классе (первое число – длина, второе - ширина), своих полей-данных класс `IntRectangle` иметь не должен. При попытке сконструировать прямоугольник с отрицательными сторонами, выбрасывайте исключение типа `BadRectangle` (класс можно оставить пустым). Функцию `Measure()` определите как площадь прямоугольника. <br><br>

Введите в классе операцию сложения, которая «склеивает» два прямоугольника: если у них одинаковая ширина – то склеиваем по длине, иначе, если одинаковая длина – то по ширине. Например, сложение прямоугольников 5х4 и 7х4 даст прямоугольник 12х4,  5х4 + 5х2 даст прямоугольник 5х6, 5х3 + 5х3 даст 10х3  Если прямоугольники не имеют двух подходящих сторон (например, 5х3 и 3x5 или 5х3 и 6х4), то выбрасывайте исключение класса `BadAdd`, в объекте которого должны содержаться стороны обоих прямоугольников, которые не удалось сложить. <br><br>

В результате следующая функция main():

```cpp
int main() { 
    try {
        IntRectangle a(5, 4), b(7, 4), c(2, 1), d(2, 3);
        IntRectangle p, q;
        p = a + b;
        q = c + d;
        cout << (p+q).Measure() << endl;
        cout << (p+d).Measure() << endl; 
    }
    catch (const BadAdd &bad) {
        cout << "Bad add: (" << bad.GetX1() << " x " << bad.GetY1() << ") + (" << bad.GetX2() << " x " << bad.GetY2() << ")\n";  
    }
    catch (BadRectangle b) { 
        cout << "Bad rectangle\n"; 
    }       
    return 0; 
}
```
должна откомпилироваться без ошибок и предупреждений, отработать и выдать:
```cpp
56
Bad add: (12 x 4) + (2 x 3)
```
Все поля должны быть в закрытой (private) части базового класса, открытыми и защищёнными могут быть только функции-члены. Использование директивы friend запрещено. Для инициализации объектов используются конструкторы. Никакие методы не должны изменять внутренние поля объектов, допускаются только функции, возвращающие значения полей (но не меняющие ничего). <br>

<br> <b> [v2_2](./v2_2.cpp): </b><br>
    
Опишите класс `Assign` (и, при необходимости другие классы) так, чтобы вычисление выражения вида `a[x](y)` (где `a` – объект класса `Assign`, `x` – переменная типа int, y - выражение, приводимое к int) заносило в переменную   х  значение  y, при этом присвоенное значение запоминалось в объекте а и могло быть получено методом `Get()`. <br><br>

<b>Пример:</b>

```cpp
int main() {
    Assign a;
    int x = -1, y = 5;
    a[x](y);
    cout << a.Get() << endl; // print 5
    cout << x << endl;       // print 5
    return 0;
}
```
