## Разработка программ-конвертеров кодировок UTF16-UTF8

*Read this in other languages: [English](README.md), [Русский](README.ru.md).*

Первая программа читает из канала ввода текст в кодировке UTF-16, переводит его в кодировку UTF-8 и выводит перекодированный текст в канал вывода ([converting_utf16_to_utf8.c](./converting_utf16_to_utf8.c)). Вторая программа читает из канала ввода текст в кодировке UTF-8, переводит его в кодировку UTF-16 и выводит перекодированный текст в канал вывода ([converting_utf8_to_utf16.c](./converting_utf8_to_utf16.c)). <br>
Если при запуске программы задан аргумент командной строки — имя файла, то вместо стандартного ввода текст берется из этого файла. Если задано два аргумента, то первый рассматривается как имя файла ввода, а второй — как имя файла вывода. Стандартные потоки ввода/вывода в этом случае не используются. В случае неправильного имени файла программа выдает сообщение об ошибке и завершается. <br>
Обе программы корректно обрабатывают маркер порядка байтов (byte order mark – BOM) – символ с кодом `0xFEFF` — в начале файла. Первая программа читает текст в UTF-16, а вторая программа — генерирует текст в UTF-16 в соответствии с прочитанным маркером. В случае отсутствия маркера принимается LE-порядок (то есть по умолчанию BOM представлен байтами `0xFF 0xFE` в начале файла). <br>
Также программы обрабатывают случаи некорректного представления входного текста — нечетное количество байтов в UTF-16, некорректные последовательности в UTF-8. В этих случаях программы  выдают в стандартный канал вывода сообщения об ошибках (stderr) диагностику, включающую в себя значение некорректного символа (последовательности), а также его смещение относительно начала файла. После этого программы «восстанавливаются» и продолжают чтение и перекодировку входной последовательности.

---

Для хранения UTF16-символов используется тип данных unsigned short, а для UTF-8 символов - char.

Двоичный образ файла (побайтно) можно посмотреть программой od (octal dump). `od le.utf`
покажет содержимое файла `le.utf` порциями по 2 байта в восьмеричном формате. Для вывода файла в 16-ичном формате побайтно используется следующий набор опций:
```bash
od -A x -t x1z -v le.utf
```
В восьмеричном формате байтов:
```bash
od -c le.utf
```
Если в системе установлена кодировка UTF-8 (что верно для многих установок), то файл в UTF-8 кодировке можно просто выдать на экран командой `cat имя_файла` или же просмотреть в любом текстовом редакторе.
Для того, чтобы просмотреть содержимое файла в любой кодировке, можно использовать редактор vim. После открытия файла командой `vim имя_файла` указывается кодировка файла командой:
```bash
:set fileencoding=ucs-2
```
Заметим, что кодировка ucs-2 использует прямой порядок байтов (big-endian). При чтении файла с обратным порядком байтов (little-endian) нужно использовать имя `ucs-2le`. Вместо `ucs-2` и `ucs-2le` можно использовать имена `utf-16` и `utf-16le`. Различия в этих кодировках не проявляются в тестовых файлах.

Команда `xxd` создаёт представление файла в виде шестнадцатеричных кодов или выполняет обратное преобразование. Пример использования:
```bash
xxd tmp.utf
```

Команда `hexedit` просмотривает и редактирует файлы в шестнадцатеричном формате или в формате ASCII. Пример использования:
```bash
hexedit tmp.utf
```

Команда `diff` ищет различия между двумя файлами. Флаг `-s` сообщает, что два файла являются одинаковыми. Пример использования:
```bash
diff ./tests/letext.ucs tmp.ucs -s
```

### Тестовые файлы

Для тестирования и отладки написан следующий (минимальный) набор файлов, который находится в каталоге `/tests`.

<b> UTF-16 файлы </b>

```bash
- letext.ucs – текст в UTF-16 в перевернутом представлении (LE-порядок) с меткой BOM
- betext.ucs – текст в UTF-16 в прямом представлении (BE-порядок) с меткой BOM
- letextbad1.ucs – текст в UTF-16 в перевернутом представлении (LE-порядок) без
метки BOM
- betextbad1.ucs – текст в UTF-16 в прямом представлении (BE-порядок) без метки
BOM
- letextbad2.ucs – текст в UTF-16 в перевернутом представлении (LE-порядок) с меткой
BOM, но с неверным символом (однобайтовым)
- betextbad2.ucs – текст в UTF-16 в прямом представлении (BE-порядок) с меткой BOM,
но с неверным символом (однобайтовым)
- leempty.ucs – пустой текст в UTF-16 в перевернутом представлении (LE-порядок) с
меткой BOM
- beempty.ucs – пустой текст в UTF-16 в прямом представлении (BE-порядок) с меткой
BOM
- le30.ucs – односимвольный (код=0x30 – символ 0) текст в UTF-16 в перевернутом
представлении (LE-порядок) с меткой BOM
- be30.ucs – односимвольный (код=0x30 – символ 0) текст в UTF-16 в прямом
представлении (BE-порядок) с меткой BOM
- le42f.ucs – односимвольный (код=0x042F – символ Я) текст в UTF-16 в перевернутом
представлении (LE-порядок) с меткой BOM
- be42f.ucs – односимвольный (код=0x042F – символ Я) текст в UTF-16 в прямом
представлении (BE-порядок) с меткой BOM
- le263A.ucs – односимвольный (код=0x263A – символ ☺) текст в UTF-16 в
перевернутом представлении (LE-порядок) с меткой BOM
- be262A.ucs – односимвольный (код=0x263A – символ ☺ текст в UTF-16 в прямом
представлении (BE-порядок) с меткой BOM
```

<b> UTF-8 файлы </b>
```bash
- text.utf – текст в UTF-8 с меткой BOM (кодированной)
- text2.utf – текст в UTF-8 без метки BOM
- textbad1.utf – текст в UTF-8 с неверной последовательностью (начинается с байта
продолжения) без метки BOM
- textbad2.utf – текст в UTF-8 с неверной последовательностью (отсутствует байт
продолжения) без метки BOM
- empty.utf – пустой текст в UTF-8 с меткой BOM
- 30.utf – односимвольный (код=0x30 – символ 0) текст в UTF-8
- 42f.utf – односимвольный (код=0x042F – символ Я) текст в UTF-8
- 263A.utf – односимвольный (код=0x263A – символ ☺) текст в UTF-8
```
