SLAE START
 EXTRN CARD, PROUT, NUMB, SYMB, CHARTOF, FTOCHAR, ADD, SUB, MUL, DIV, DR, M1, NREL
 ENTRY GO

GO = <PROUT '\nРезультат:\n'<START_CYCLE <START_WORK <CHECK_NUM <CARD 'Число уравнений = '>>>>>

*---------------------------------------------------------------------------------
* CHECK_NUM проверяет, что введено в качестве количества уравнений.

CHECK_NUM '-'e1 = 'ОШИБКА: введено отрицательное количестве уравнений\n'
          '0' = 'Пустая система\n'
          s(D)Ae(D)1 = <NUMB sAe1>
          e1 = 'ОШИБКА: введено не число\n'
*---------------------------------------------------------------------------------

*---------------------------------------------------------------------------------
* START_WORK, START_SYS и SYS переводят систему:
* EQ1
* EQ2
* EQ3,
* в запись  INT_REPR(EQ1);INT_REPR(EQ2);INT_REPR(EQ3).

START_WORK e1'\n' = e1'\n'
           e1 = <PROUT 'Система:'><START_SYS e1>

START_SYS e1'ОШИБКА'e2'\n'e3 = 'ОШИБКА'e2'\n'
          sAe1 = <SYS <NREL (sA)/0/>e1>

SYS '>'(sA)sBe1 = <START_SYS <M1 sA>e1<INT_REPR <CARD>>';'>
    '='(sA)sBe1';' = e1
*---------------------------------------------------------------------------------

*---------------------------------------------------------------------------------
* INT_REPR переводит уравнение вида:
* a*x + b*y + c*z + ... = d,
* во внутреннее представление следующего вида:
* (/a/)/x/(/b/)/y/(/c/)/z/...(/d/).

* Последовательно вызываются следующие функции:
* DEL_SPACE удаляет все пробелы;
* VARTOF переводит переменные (s(L)e(LD)) в символ-метки;
* SKOB заменяет символьные скобки структурными;
* PUT_BR заключает в структурные скобки коэффициенты и свободный член уравнения, причем знаки '*' и '=' удаляются;
* CAL_COEF вычисляет коэффициенты и свободный член, причем вычисления производятся по БНФ, как на семинаре;
* CHECK_ERROR протаскивает запись об ошибке в вышележащие функции.

INT_REPR e1 = <CHECK_ERROR <CAL_COEF <PUT_BR <BALANCE <SKOB <VARTOF <DEL_SPACE e1>>>>>>>

DEL_SPACE e1' 'e2 = e1<DEL_SPACE e2>
          e1 = e1

VARTOF e1s(L)Ae(LD)2s((LD))Be3 = e1<CHARTOF sAe2><VARTOF sBe3>
       e1s(L)Ae(LD)2 = e1<CHARTOF sAe2>
       e1 = e1

SKOB e1')'e2 = <SKOB <SK e1')'>e2>
     e1'('e2 = 'ОШИБКА: нарушен баланс скобок\n'
     e1 = e1

SK R e1'('e2')' = e1(e2)
     e1 = 'ОШИБКА: нарушен баланс скобок\n'

* ----------------- новые функции -----------------     

BALANCE e1 = <BALANCE_CONST <BALANCE_VAR e1>>

BALANCE_VAR e1'='e2s(F)Ae3 = e1<VAR_TO_LEFT '='e2sAe3>
            e1 = e1

VAR_TO_LEFT '='e((F))1'+'e2s(F)Ae3 = '-'e2sA<VAR_TO_LEFT '='e1e3>
            '='e((F))1'-'e2s(F)Ae3 = '+'e2sA<VAR_TO_LEFT '='e1e3>
            '='e1s(F)Ae2 = '-'e1sA<VAR_TO_LEFT '='e2>
            e1 = e1

BALANCE_CONST e1'=' = <BALANCE_CONST e1'=0'>
              '-'(e1)'+'e2'='e3 = <BALANCE_CONST e2'='e3'+'(e1)>
              '-'(e1)'-'e2'='e3 = <BALANCE_CONST '-'e2'='e3'+'(e1)>
              (e1)'-'e2'='e3 = <BALANCE_CONST '-'e2'='e3'-'(e1)>
              (e1)'+'e2'='e3 = <BALANCE_CONST e2'='e3'-'(e1)>
              e1'+'e((F))2s('+-')Be3'='e4 = <BALANCE_CONST e1sBe3'='e4'-'e2>
              e1'-'e((F))2s('+-')Be3'='e4 = <BALANCE_CONST e1sBe3'='e4'+'e2>
              '-'e((F))1'*'s(F)A'='e2 = '-'e1'*'sA'='e2
              s((F))Ae((F))1'+'e2'='e3 = <BALANCE_CONST e2'='e3'-'sAe1>
              s((F))Ae((F))1'-'e2'='e3 = <BALANCE_CONST '-'e2'='e3'-'sAe1>
              e1'+'e((F))2'='e3 = e1'='e3'-'e2
              e1'-'e((F))2'='e3 = e1'='e3'+'e2
              e((F))1'='e2 = '='e2'+'e1
              e1 = e1
                            
* ----------------- новые функции -----------------   

PUT_BR s(F)Ae1 = ('1')sA<PUT_BR e1>
       '+'s(F)Ae1 = ('1')sA<PUT_BR e1>
       '-'s(F)Ae1 = ('-1')sA<PUT_BR e1>
       e1'*'s(F)Ae2 = (e1)sA<PUT_BR e2>
       '='e1 = (e1)
       e1'ОШИБКА'e2'\n'e3 = 'ОШИБКА'e2'\n'

CAL_COEF e1('ОШИБКА'e2)e3 = 'ОШИБКА'e2
         e1'ОШИБКА'e2'\n'e3 = 'ОШИБКА'e2'\n'
         (e1)sAe2 = (<VYR e1>)sA<CAL_COEF e2>
         (e1) = (<VYR e1>)

CHECK_ERROR e1('ОШИБКА'e2)e3 = 'ОШИБКА'e2
            'ОШИБКА'e2 = 'ОШИБКА'e2
            e1 = e1
*---------------------------------------------------------------------------------

*---------------------------------------------------------------------------------
* VYR, Z1, SLAG, Z2, MNOJ осуществляют вычисление выражения по следующей БНФ:
* <выражение> ::= <слагаемое> | <выражение><знак1><слагаемое>
* <знак1> ::= + | -
* <слагаемое> ::= <множитель> | <слагаемое><знак2><множитель>
* <знак2> ::= * | /
* <множитель> ::= (<выражение>) | <целое число>
* <целое число> ::= 0, 1, -1, 2, -2, ..., 
* причем все числа переводятся в рациональные дроби, например 1 -> 1/1, 2->2/1 и т.д.

VYR R e1s('+-')Ae2 = <Z1 sA(<VYR e1>)<SLAG e2>>
      e1 = <SLAG e1>

Z1 '+'(e1)e2 = <ADD_FRAC (e1)e2>
   '-'(e1)e2 = <SUB_FRAC (e1)e2>

SLAG R e1s('*/')Ae2 = <Z2 sA(<SLAG e1>)<MNOJ e2>>
       e1 = <MNOJ e1>

Z2 '*'(e1)e2 = <MUL_FRAC (e1)e2>
   '/'(e1)/0/e2 = 'ОШИБКА: деление на ноль\n'
   '/'(e1)e2 = <DIV_FRAC (e1)e2>

MNOJ (e1) = <VYR e1>
     e1 = <NUMB e1>'/'/1/
*---------------------------------------------------------------------------------


*---------------------------------------------------------------------------------
* Следующие функции обеспечивают работу с дробными числами вида a/b.
* REDUCE, SUBRED отвечают за сокращение дроби;
* NOD вычисляет НОД рекурсивным алгоритмом Евклида;
* MOD вычисляет остаток от деления после выполнения функции DR;
* FRACTOCHAR переводит дробь вида: /a/'/'/b/, в последовательность символов 'a/b'
* ADD_FRAC - сложение дробей
* SUB_FRAC - вычитание дробей
* MUL_FRAC - умножение дробей
* DIV_FRAC - деление дробей

REDUCE '-'e1'/-'e2 = <SUBRED (<NOD (e1)e2>)e1'/'e2>
       '-'e1'/'e2 = '-'<SUBRED (<NOD (e1)e2>)e1'/'e2>
       e1'/-'e2 = '-'<SUBRED (<NOD (e1)e2>)e1'/'e2>
       e1'/'e2 = <SUBRED (<NOD (e1)e2>)e1'/'e2>

SUBRED (e1)e2'/'e3 = <DIV (e2)e1>'/'<DIV (e3)e1>

NOD (e1)/0/ = e1
    (e1)e2 = <NOD (e2)<MOD <DR (e1)e2>>>

MOD e1(e2) = e2

FRACTOCHAR /0/e1 = '0'
           e1'/'/1/ = <SYMB e1>
           e1'/'e2 = <SYMB e1>'/'<SYMB e2>

ADD_FRAC (e1'/'e2)e3'/'e4 = <REDUCE <ADD (<MUL (e1)e4>)<MUL (e2)e3>>'/'<MUL (e2)e4>>

SUB_FRAC (e1'/'e2)e3'/'e4 = <REDUCE <SUB (<MUL (e1)e4>)<MUL (e2)e3>>'/'<MUL (e2)e4>>

MUL_FRAC (e1'/'e2)e3'/'e4 = <REDUCE <MUL (e1)e3>'/'<MUL (e2)e4>>

DIV_FRAC (e1'/'e2)e3'/'e4 = <REDUCE <MUL (e1)e4>'/'<MUL (e2)e3>>
*---------------------------------------------------------------------------------

*---------------------------------------------------------------------------------
* START_CYCLE, CYCLE, ITERATION запускают цикл, в котором:
* 1) Все уравнения переводятся в каноническую форму, то есть приводятся подобные слагаемые;
* 2) В первом уравнении первая переменная выражается через остальные;
* 3) Полученное выражение подставляется в оставшиеся уравнения,
* причем в итоге мы получим упрощенные уравнения, но в обратном порядке: EQ3;EQ2;EQ1.

START_CYCLE e1'\n' = e1'\n'
            e1 = <CYCLE <VAR_SET e1>e1'|'>

CYCLE (e1)e2'|'e3 = <CHECK_FIRST (e1)<CANON_FORM e2>'|'e3>

ITERATION (e1)e2'|'e3 = <CHECK_ITER (e1)<SUBSTITUTION <EXP_VAR e2>'|'e3>>
*---------------------------------------------------------------------------------

*---------------------------------------------------------------------------------
* CHECK_ITER проверяет, не завершился ли первый цикл, чтобы начать второй.

CHECK_ITER (e1)e2'|' = <DESISION (e1)<CYCLE2 e2'|'>>
           e1 = <CYCLE e1>
*---------------------------------------------------------------------------------

*---------------------------------------------------------------------------------
* VAR_SET, PUT_VAR создают множество всех переменных, встречающихся в исходной системе.

VAR_SET e1 = <PUT_VAR ()e1>

PUT_VAR (e1)e2s(F)Ae3 = <PUT_VAR <PUT sA(e1)>e3>
        (e1)e2 = (e1)
*---------------------------------------------------------------------------------

*---------------------------------------------------------------------------------
* Операции для работы с множествами:
* PUT кладет элемент в множество;
* GET забирает элемент из множества.

PUT sA(e1sAe2) = (e1sAe2)
    sA(e1) = (e1sA) 

GET sA(e1sAe2) = (e1e2)
    e1 = e1
*---------------------------------------------------------------------------------

*---------------------------------------------------------------------------------
* CHECK_FIRST проверяет, не является ли первое уравнение тождеством.
* Если оно является истинным тождеством, то данное уравнение удаляется из системы,
* иначе выводится сообщение 'Система уравнений не имеет решения'.

CHECK_FIRST (e1)(/0/e2)';'e3'|' = <CHECK_FIRST  (e1)e3'|'>
            (e1)(/0/e2)';'e3 = <CHECK_ITER (e1)e3>
            (e1)(/0/e2)'|'e3';' = <CHECK_ITER (e1)e3'|'>
            (e1)(/0/e2)'|'e3 = <CHECK_ITER (e1)e3'|'>
            (e1)(e2)s(';|')Ae3 = 'Система уравнений не имеет решения'
            e1 = <ITERATION e1>
*---------------------------------------------------------------------------------

*---------------------------------------------------------------------------------
* Второй цикл отвечает за последовательную подстановку полученных выражений в последующие уравнения,
* то есть EQ3 -> EQ2, EQ1; EQ2 -> EQ1, причем в итоге мы имеем следующий порядок: EQ1;EQ2;EQ3, где
* все уравнения максимально упрощены.

CYCLE2 e1';'e2'|'e3 = <CYCLE2 <CANON_FORM <SUB_TO_EACH e1';'e2>>'|'e1';'e3>
       e1'|'e2';' = e1';'e2
       e1'|' = e1
*---------------------------------------------------------------------------------

*---------------------------------------------------------------------------------
* Перевод результата в символы:
* DESISION последовательно перебирает все уравнения. После последнего уравнения отправляет множество своб. перем. на обработку;
* MAKE переводит переменные из символ-меток в символы и отправляет оставшееся выражение на обработку;
* ALLTOCHAR, SIGN переводит линейную комбинацию коэф. и перем. в символы, причем за добавление знака перед очередным слагемым отвечает SIGN;
* MAKE_FREE вызывает после перевода всего доступного в символы для обработки множества свободных переменных.

DESISION e1(e2)e3';'e4 = <DESISION e1<MAKE e3(e2)>e4>
         e1(e2)e3 = <MAKE_FREE e1<MAKE e3(e2)>>

MAKE sA(e1)(e2) = <FTOCHAR sA>' = '<FRACTOCHAR e1>'\n'<GET sA(e2)>
     sA(/0/e2)e3(e4) = <FTOCHAR sA>' = '<ALLTOCHAR e3>'\n'<GET sA(e4)>
     sA(e1)('-'e2)e3(e4) = <FTOCHAR sA>' = '<FRACTOCHAR e1><ALLTOCHAR ('-'e2)e3>'\n'<GET sA(e4)>
     sA(e1)(e2)e3(e4) = <FTOCHAR sA>' = '<FRACTOCHAR e1>'+'<ALLTOCHAR (e2)e3>'\n'<GET sA(e4)>
     (e1) = (e1)

ALLTOCHAR ('-'/1/'/'/1/)sAe1 = '-'<FTOCHAR sA><SIGN e1>
          (/1/'/'/1/)sAe1 = <FTOCHAR sA><SIGN e1>
          (e1)sAe2 = <FRACTOCHAR e1>'*'<FTOCHAR sA><SIGN e2>

SIGN ('-'e1)e2 = <ALLTOCHAR ('-'e1)e2>
     (e1)e2 = '+'<ALLTOCHAR (e1)e2>
     e1 = e1

MAKE_FREE e1(sAe2) = <MAKE_FREE e1(e2)><FTOCHAR sA>' - свободная переменная\n'
          e1() = e1
*---------------------------------------------------------------------------------

*---------------------------------------------------------------------------------
* Приведение к канонической форме всех уравнений системы:
* CANON_FORM переводит каждое уравнение в каноническую форму;
* CANON_ALL отвечает за выбор очередного уравнения;
* CANON_ONE приводит подобные слагаемые в очередном уравнении;
* DEL_ZERO удаляет из всех уравнений записи вида: 0*x.

CANON_FORM e1 = <DEL_ZERO <CANON_ALL e1>>

CANON_ALL e1';'e2 = <CANON_ONE e1>';'<CANON_ALL e2>
          e1 = <CANON_ONE e1>

CANON_ONE e1(e2)sAe3(e4)sAe5 = e1<CANON_ONE (<ADD_FRAC (e2)e4>)sAe3e5>
          e1(e2)(e3) = e1(<ADD_FRAC (e2)e3>)
          e1 = e1

DEL_ZERO e1(/0/e2)s(F)Ae3 = <DEL_ZERO e1e3>
         e1 = e1
*---------------------------------------------------------------------------------

*---------------------------------------------------------------------------------
* Выражение первой переменной в первом уравнении системы, через оставшиеся переменные
* (x = -2*y + z + 5 хранится в виде: /x/(/5/'/'/1/)(-/2/'/'/1/)/y/(/1/'/'/1/)/z/, то есть свободный член в начале):
* EXP_VAR достает первое уравнение;
* EXP выражает из уравнения первую переменную через оставшиеся;
* VAR_MINUS изменяет знаки коэффициентов на противоположные при необходимости для переноса в правую часть равенства;
* VAR_TO_RIGHT переносит оставшиеся (кроме первой) переменные в правую часть, причем знаки коэффициентов изменены заранее;
* DIV_COEF, DIV_VAR делят оставшиеся (кроме первого) коэф. и свободный член на коэф. перед первой переменной.

EXP_VAR e1';'e2 = <DIV_COEF <EXP e1>>';'e2
        e1 = <DIV_COEF <EXP e1>>

EXP ('-'e1)sAe2('-'e3) = (e1)sA<VAR_TO_RIGHT e2(e3)>
    ('-'e1)sAe2(e3) = (e1)sA<VAR_TO_RIGHT e2('-'e3)>
    (e1)sAe2 = (e1)SA<VAR_TO_RIGHT <VAR_MINUS e2>>

VAR_MINUS ('-'e1)sAe2 = (e1)sA<VAR_MINUS e2>
          (e1)sAe2 = ('-'e1)sA<VAR_MINUS e2>
          e1 = e1

VAR_TO_RIGHT e1(e2) = (e2)e1

DIV_COEF (e1)sA(e2)e3 = sA(<DIV_FRAC (e2)e1>)<DIV_VAR (e1)e3>

DIV_VAR (e1)(e2)sBe3 = (<DIV_FRAC (e2)e1>)sB<DIV_VAR (e1)e3>
        (e1) =
*---------------------------------------------------------------------------------


*---------------------------------------------------------------------------------
* Подстановка выраженной переменной из первого уравнения в оставшиеся уравнения:
* SUBSTITUTION выбирает первое уравнение. В случае, если они и последнее, то переставляет знак '|' в конец;
* SUB_TO_EACH подставляет выраженное первое уравнение в оставшиеся;
* SUBS ищет нужную переменную (из 1 уравнения) в оставшихся и подставляет в них;
* MUL_COEF перемножает коэффициенты и свободный член на коэффициент перед встреченной переменной.

SUBSTITUTION e1';'e2'|'e3 = <SUB_TO_EACH e1';'e2>'|'e1';'e3
             e1'|' = e1'|'
             e1'|'e2';' = e1';'e2'|'
             e1'|'e2 = e1';'e2'|'

SUB_TO_EACH e1';'e2';'e3 = <SUBS e1';'e2>';'<SUB_TO_EACH e1';'e3>
            e1 = <SUBS e1>

SUBS sA('-'e1)e2';'e3(e4)sAe5(e6) = e3<MUL_COEF (e4)e2>e5(e6)(<MUL_FRAC (e4)e1>)
     sA(e1)e2';'e3(e4)sAe5(e6) = e3<MUL_COEF (e4)e2>e5(e6)(<MUL_FRAC (e4)'-'e1>)
     sA(e1)e2';'sB(e3)e4(e5)sAe6 = sB(<ADD_FRAC (e3)<MUL_FRAC (e5)e1>>)e4<MUL_COEF (e5)e2>e6
     e1';'e2 = e2

MUL_COEF (e1)(e2)sAe3 = (<MUL_FRAC (e1)e2>)sA<MUL_COEF (e1)e3>
         (e1)(e2)e3 = (<MUL_FRAC (e1)e2>)<MUL_COEF (e1)e3>
         (e1) = 